Great—thanks for the grep dump. That gives us the smoking gun:

## What’s actually wrong

1. **Env var name mismatch**

   * `server/diagnostics.ts` checks **`SCREENSHOT_MACHINE_KEY`** (with an underscore).
   * The real code path uses **`SCREENSHOTMACHINE_KEY`** (no underscore) in:

     * `server/services/screenshotExternal.ts`
     * `server/controllers/heatmap.screenshot.ts`

   So diagnostics always reports “No provider API key configured”, even if the key exists. More importantly, anyone following diagnostics would set the **wrong** env name.

2. **AI route uses a slightly stricter screenshot path**

   * `AI` path: `server/services/aiHeatmap.ts` → `getScreenshotBuffer(...)` (in `server/services/screenshot.ts`) → retries + throws `ScreenshotError("PROVIDER_FAILED")` if the provider isn’t happy.
   * `Data` path: `server/controllers/heatmap.data.ts` uses `getExternalScreenshotBase64` directly and **worked** (you got a green PASS).
   * So your external screenshot provider is reachable (since Data passed), but the **AI path is failing its stricter wrapper**.

## Quick, precise fixes

### 1) Fix diagnostics env mismatch (so the truth shows up)

Edit **`server/diagnostics.ts`**:

* Replace every occurrence of `SCREENSHOT_MACHINE_KEY` with `SCREENSHOTMACHINE_KEY`.

You should see two spots:

```ts
// before
const hasKey = process.env.THUM_IO_KEY || process.env.SCREENSHOT_MACHINE_KEY;
// after
const hasKey = process.env.THUM_IO_KEY || process.env.SCREENSHOTMACHINE_KEY;

// before
if (process.env.SCREENSHOT_MACHINE_KEY) return "screenshotmachine";
// after
if (process.env.SCREENSHOTMACHINE_KEY) return "screenshotmachine";
```

### 2) Add a resilient fallback in the AI path (keeps you moving)

In **`server/services/aiHeatmap.ts`**, the first screenshot step is:

```ts
// current
const { png: screenshotPng } = await getScreenshotBuffer(url, device);
```

Wrap it so if the buffer path fails, we **fall back** to the same base64 path the **Data** route uses (which we know works):

```ts
import { getExternalScreenshotBase64 } from "./screenshotExternal";

// ...
let screenshotPng: Buffer;
try {
  const { png } = await getScreenshotBuffer(url, device);
  screenshotPng = png;
} catch (e:any) {
  // Fallback to the provider path used by the Data route (works on your env)
  const { image: b64 } = await getExternalScreenshotBase64(url, device);
  const pngData = b64.replace(/^data:image\/[a-z]+;base64,/, "");
  screenshotPng = Buffer.from(pngData, "base64");
}
```

> This doesn’t change output format (still base64 in the final response) and it doesn’t add new deps. It just makes AI behave like Data when the stricter wrapper isn’t happy.

### 3) (Optional but recommended) Set the screenshot key explicitly

Even though `screenshotExternal` falls back to `"free"`, it’s better to be explicit and quiet diagnostics:

* In Replit **Secrets**, add:

  * `SCREENSHOTMACHINE_KEY = free`
    *(or your real key if you have one — the free tier can watermark/limit but is fine for smoketests)*

* If you use **Thum.io** instead:

  * `THUM_IO_KEY = <your key>`

### 4) Restart and re-test

* Restart the app.
* Re-run your adjusted Step-2 smoketest.

You should now see:

* `/health` → PASS
* `/dev/heatmap` markers → PASS
* **AI route** → PASS (either via buffer path or fallback)
* Data route → PASS

If AI still fails, paste the first 20–30 lines of the AI endpoint’s raw 500 body (the script prints a snippet) **and** the diagnostics snippet again — but with the env mismatch fixed we’ll get accurate provider status, which makes the next step trivial.
