Here’s a clean, copy-paste brief you can give to Replit’s AI assistant. It standardizes our API to **base64-only** and makes the overlay available at a new endpoint while keeping your existing screenshot endpoint untouched.

---

# Goal

1. Keep current **screenshot** endpoint (`POST /api/v1/heatmap`) returning **base64 only**.
2. Add a new **overlay** endpoint (`POST /api/v1/heatmap/overlay`) that draws the Phase-4 red rectangle and also returns **base64 only**.
3. Standardize the response field name to **`image`** (a `data:image/png;base64,...` string) for **all** heatmap endpoints to avoid client confusion.

---

# Changes to make

## 1) Wire a new overlay route

**File:** `server/routes.ts`
**Edit:** import the overlay controller and add a new route.

```ts
// ADD (near other imports)
import { postHeatmap } from "./controllers/heatmap"; // overlay controller (canvas-based)

// FIND the existing /api/v1/heatmap (screenshot) route and keep it AS-IS.
// THEN ADD THIS NEW ROUTE just below it:

app.post(
  "/api/v1/heatmap/overlay",
  perIpLimiter,
  requestTimeout(45_000),
  postHeatmap, // ← uses imaging.ts to draw rectangle, returns base64 data URI
);
```

> Do not delete the existing screenshot route; we’re adding a sibling route for the overlay.

---

## 2) Make the overlay controller return a unified `image` field

**File:** `server/controllers/heatmap.ts` (the overlay controller file; function likely named `postHeatmap`)
**Edit:** ensure the response JSON uses **`image`** (not `base64`) and that it returns the **composited** output from `imaging.ts`.

Inside `postHeatmap`, after generating the screenshot base64 and calling the overlay:

```ts
// PSEUDO (keep your existing screenshot acquisition):
// const screenshotBase64 = await screenshotToBase64({ url, device });

// Call the overlay with obvious rectangle for Phase 4
const result = await overlayRectangleOnBase64Png(screenshotBase64, {
  x: 50, y: 50, w: 600, h: 400, alpha: 0.5
});

// IMPORTANT: respond with 'image' not 'base64'
res.json({
  meta: {
    sourceUrl: url,
    device,
    returnMode: "base64",
    requestId,
    durationMS
  },
  image: result.base64  // ← unified field name
});
```

* If this file currently returns `{ base64: ... }`, change it to `{ image: ... }`.
* Keep everything else (logging, error handling) intact.

---

## 3) (Confirm) Imaging service draws AFTER the screenshot

**File:** `server/services/imaging.ts`
Ensure the overlay function draws screenshot first, then the rectangle. Minimum viable body:

```ts
// after loadImage()
const canvas = createCanvas(image.width, image.height);
const ctx = canvas.getContext("2d");

// 1) Draw screenshot first
ctx.drawImage(image, 0, 0);

// 2) Draw one visible rectangle for Phase 4
ctx.save();
ctx.globalAlpha = 0.5;
ctx.fillStyle = "#FF0000";
ctx.fillRect(50, 50, 600, 400);
ctx.restore();

// Optional border to guarantee visibility
ctx.save();
ctx.lineWidth = 3;
ctx.strokeStyle = "rgba(255,255,255,0.9)";
ctx.strokeRect(50, 50, 600, 400);
ctx.restore();

// export PNG → base64 data URI
const buffer = canvas.toBuffer("image/png");
return { base64: `data:image/png;base64,${buffer.toString("base64")}`, width: image.width, height: image.height };
```

* Keep the existing function signature; just ensure the overlay is **clearly visible**.

---

# Testing instructions (PowerShell)

> Replace `$BASE` with your Replit URL.

## A) Existing screenshot endpoint (no overlay)

```powershell
$BASE = "https://<your-replit>.spock.replit.dev"

$resp = Invoke-RestMethod -Uri "$BASE/api/v1/heatmap" `
  -Method POST -ContentType "application/json" `
  -Body (@{ url = "https://www.acquisition.com/"; device = "desktop" } | ConvertTo-Json)

# Save the returned base64 image
$data = ([string]$resp.image -split ',', 2)[-1]
[IO.File]::WriteAllBytes("$PWD\screenshot.png", [Convert]::FromBase64String($data))
Start-Process "$PWD\screenshot.png"
```

Expected: clean screenshot (no rectangle).

## B) New overlay endpoint (rectangle visible)

```powershell
$BASE = "https://<your-replit>.spock.replit.dev"

$resp = Invoke-RestMethod -Uri "$BASE/api/v1/heatmap/overlay" `
  -Method POST -ContentType "application/json" `
  -Body (@{ url = "https://www.acquisition.com/"; device = "desktop" } | ConvertTo-Json)

$data = ([string]$resp.image -split ',', 2)[-1]
[IO.File]::WriteAllBytes("$PWD\overlay.png", [Convert]::FromBase64String($data))
Start-Process "$PWD\overlay.png"
```

Expected: same screenshot **with** a large semi-transparent **red rectangle** (50,50,600×400) and a white border.

---

# Acceptance checklist

* `POST /api/v1/heatmap` returns JSON with an **`image`** field (data URI) of the **raw screenshot**.
* `POST /api/v1/heatmap/overlay` returns JSON with an **`image`** field (data URI) of the **composited** screenshot + rectangle.
* Both calls succeed for at least 2 different URLs and save decodable PNGs > 100KB.
* The overlay is clearly visible. If not, increase alpha or dimensions temporarily for Phase 4.

---

If any file names differ in your repo (e.g., the overlay controller file), apply the same edits to the actual paths you have.
