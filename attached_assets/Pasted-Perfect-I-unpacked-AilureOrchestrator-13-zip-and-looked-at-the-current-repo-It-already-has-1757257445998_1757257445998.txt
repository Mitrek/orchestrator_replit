Perfect — I unpacked **AilureOrchestrator(13).zip** and looked at the *current* repo. It already has a solid Express + Vite TS stack, API key middleware, and a stubbed `server/services/heatmap.ts`. Below is a **refined, repo-aware plan** you can paste to Replit AI so it implements the real heatmap engine cleanly inside *this exact project*, without changing unrelated parts.

---

# Replit To-Do — Implement Heatmap Engine (AI & Data) in this Repo

## TL;DR

Ship two API endpoints behind the existing auth, powered by Puppeteer + `@napi-rs/canvas`, with OpenAI for AI mode and JSONL streaming for Data mode. Keep everything TypeScript ESM and use **relative imports** only. Reuse one browser instance. Save PNGs under `public/outputs/` and return either URL or base64.

---

## 0) Read the Current Structure (do not break)

* Keep **ESM** (`"type": "module"` is set).
* Keep the dev/build scripts:

  * `dev`: `tsx server/index.ts`
  * `build`: `vite build && esbuild server/index.ts … --outdir=dist`
  * `start`: `node dist/index.js`
* Keep **auth** & **rate limit** flows in `server/routes.ts`, `server/middleware/*`.
* Keep Vite + React UI flow in `public/` (we’ll just add a tiny test page).
* We already have a stub at `server/services/heatmap.ts`. We’ll expand it and add a few focused modules.

---

## 1) Install Runtime Dependencies

Add packages that do not require native toolchains:

```bash
npm i puppeteer @napi-rs/canvas pino openai zod
# (zod may already be present; skip if so)
```

Notes:

* Prefer **`@napi-rs/canvas`** (prebuilt) over `canvas` to avoid build failures on Replit.
* Puppeteer will download Chromium; we’ll launch with `--no-sandbox` on Replit.

---

## 2) Create New Server Modules

Create these files under `server/` (TypeScript, ESM, relative imports only):

```
server/
  services/
    heatmap.ts               # expand the existing stub (export API surface only)
  lib/
    browser.ts               # puppeteer lifecycle (singleton)
    aiPredictor.ts           # OpenAI call + fallback heuristic
    dataProcessor.ts         # JSONL streaming, segmentation, coordinate mapping
    heatmapRenderer.ts       # draw overlay using @napi-rs/canvas
    validate.ts              # zod schemas & narrow type guards
    files.ts                 # output paths, ensure dirs, cleanup helpers
  routes/
    heatmap.ts               # register /api/v1/heatmap/* endpoints
```

### 2.1 `lib/browser.ts` (singleton + helpers)

* Expose `getBrowser()` and `withPage<T>(fn: (page) => Promise<T>)` that reuses a single browser and safely closes pages.
* Launch with:

```ts
import puppeteer, { Browser } from "puppeteer";

let browser: Browser | null = null;

export async function getBrowser(): Promise<Browser> {
  if (browser && (await browser.process())?.pid) return browser;
  browser = await puppeteer.launch({
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
    headless: true,
  });
  return browser;
}

export async function withPage<T>(fn: (page: puppeteer.Page) => Promise<T>) {
  const b = await getBrowser();
  const page = await b.newPage();
  try {
    page.setDefaultNavigationTimeout(120_000);
    page.setDefaultTimeout(120_000);
    return await fn(page);
  } finally {
    await page.close();
  }
}
```

* Add utilities for:

  * `screenshotFullPage()` → get tall PNG buffer.
  * `screenshotViewport(width, height)` → get initial viewport PNG.
  * `extractAboveTheFoldDOM(page)` → return simplified DOM candidates (text blocks, buttons, images) **without mutating layout** (inject CSS to hide cookie banners, don’t remove elements).

### 2.2 `lib/aiPredictor.ts`

* Export `predictHotspots(domSummary, viewport)`:

  * If `process.env.OPENAI_API_KEY` is present, call **OpenAI Responses API** (text) to rank the most eye-catching elements among the provided DOM candidates and return normalized hotspots `[{ x:0..1, y:0..1, w:0..1, h:0..1, score:0..1 }]`.
  * Else fallback heuristic: weight by size, position (center bias), contrast hints (buttons/links/headlines).

> Important: **Do not** use deprecated `response_format`; use the current `text.format` per the latest OpenAI docs.

### 2.3 `lib/dataProcessor.ts`

* Export:

  * `streamJsonl(filePath: string): AsyncGenerator<Session>` (line-by-line, low memory).
  * `segmentByViewport(session): 'desktop'|'tablet'|'mobile'` by **aspect ratio** buckets.
  * `normalizedToAbsolute({x,y, sx, sy}, {pageHeight, viewportHeight})`:

    * For each point with normalized coordinates and scroll y (`sy` in 0..1), compute **absolute pixel Y** on the tall screenshot:
      `absY = sy * (pageHeight - viewportHeight) + y * viewportHeight`
    * `absX = x * viewportWidth` (per the segment reference viewport).
* Maintain 3 segment collectors with a **single screenshot** per segment (representative width/height).

### 2.4 `lib/heatmapRenderer.ts`

* Using `@napi-rs/canvas`:

  * `renderHeatmap(baseScreenshot: Buffer, points: Point[], opts): Buffer`:

    * Draw a dark translucent overlay.
    * Rasterize a gaussian spot for each point with intensity by `score` or click density.
    * Colorize into blue→green→yellow→red scale.
    * Return final PNG buffer.
* Provide `renderAboveTheFoldHeatmap` (AI mode) and `renderDataHeatmap` (per segment).

### 2.5 `lib/validate.ts`

* Zod schemas for incoming requests:

  * `AIRequest`: `{ url: string, viewport?: {width:number, height:number}, return?: 'base64'|'url' }`
  * `DataRequest`: `{ url: string, dataMode: { return?: 'base64'|'url' }, segments?:{ desktop?:{w,h}, tablet?:{w,h}, mobile?:{w,h} } }`
* Narrow types for internal usage.

### 2.6 `lib/files.ts`

* Ensure and write outputs to `public/outputs/`.
* Generate filenames like `outputs/ai_<nanoid>.png` or `outputs/data_<segment>_<nanoid>.png`.
* Return public URL `/<that path>` (Express already serves `public/` statically via Vite middleware; if not, keep `express.static('public')`).

---

## 3) Wire the HTTP Endpoints

Create `server/routes/heatmap.ts` and register it from `server/routes.ts` (next section).

**Security**: apply `apiKeyAuth` (and `ensurePremium` if you want to keep it paywalled).

### 3.1 `POST /api/v1/heatmap/ai`

* Body: `{ url, viewport?:{width,height}, return?:'base64'|'url' }`
* Steps:

  1. Validate with zod.
  2. `withPage(page => navigate + extract dom + screenshot viewport)`
  3. `predictHotspots(domSummary, viewport)`
  4. `renderAboveTheFoldHeatmap(viewportScreenshot, hotspots)`
  5. If `return:'url'` → save under `public/outputs/` and return `{ url, meta }`. Else return `{ base64: 'data:image/png;base64,...', meta }`.

### 3.2 `POST /api/v1/heatmap/data`

* Accept either:

  * JSON body with a `dataUrl` (public URL to the `.jsonl`), or
  * a **multipart** upload field `file` (use `multer`) for `.jsonl`.
* Steps:

  1. Validate request.
  2. Take one **representative full-page screenshot per segment** (desktop/tablet/mobile) by setting viewport and capturing once per segment.
  3. `streamJsonl` and aggregate absolute points into segment bins.
  4. For each segment with data: `renderDataHeatmap(screenshot, points)`.
  5. Return `{ segments: { desktop?: {url|base64}, tablet?:..., mobile?:... }, meta }`.

### 3.3 Register routes

In `server/routes.ts`, import and register:

```ts
import { registerHeatmapRoutes } from "./routes/heatmap";
// ...
export function registerRoutes(app: Express): Server {
  // (existing code...)
  registerPingRoute(app);
  registerHeatmapRoutes(app); // <— add this
  // ...
}
```

**Rate limiting**: reuse the existing limiter per route, e.g., 10 req/minute for heatmap endpoints.

---

## 4) Expand `server/services/heatmap.ts` (keep as thin façade)

Keep `services/heatmap.ts` as **the orchestrator that routes to lib**. It should expose:

```ts
export async function generateAI(params: {
  url: string;
  viewport?: { width: number; height: number };
  mode?: "base64" | "url";
}) { /* calls browser.ts + aiPredictor.ts + heatmapRenderer.ts */ }

export async function generateFromData(params: {
  url: string;
  dataPath: string; // or dataUrl handled earlier
  mode?: "base64" | "url";
}) { /* calls browser.ts + dataProcessor.ts + heatmapRenderer.ts */ }
```

And export types: `HeatmapParams`, etc. You’ll call these from `routes/heatmap.ts`.

---

## 5) Frontend Test Harness (minimal)

Add a tiny page at `public/index.html` to test both endpoints:

* A form with:

  * URL input
  * Select: AI / Data
  * File input for `.jsonl` (only visible for Data)
  * Return mode: base64 or url
* POST via `fetch` to `/api/v1/heatmap/ai` or `/api/v1/heatmap/data` with `x-api-key` header.
* Preview the returned image(s).

*(No need to touch Vite React app unless you want a fancier UI later.)*

---

## 6) Environment & Replit

### 6.1 Vars

* Add to Secrets:

  * `OPENAI_API_KEY` (optional; code falls back to heuristic if missing)
  * `PUPPETEER_SKIP_CHROMIUM_DOWNLOAD` (leave **unset** so it downloads)
* If Replit blocks sandboxed Chrome, we already launch with `--no-sandbox`.

### 6.2 Static files

* Ensure `public/` is mounted via `express.static` (the Vite helper already does; if not, add it in `server/vite.ts` / `serveStatic`).

---

## 7) Build Pipeline

No structural changes needed; just ensure new files are discoverable by `esbuild`:

* Keep `esbuild server/index.ts --packages=external --bundle --format=esm --outdir=dist`.
* Because we’re using only **relative imports**, the bundle should succeed without path alias issues.

---

## 8) Acceptance Tests (copy/paste)

**Ping (sanity check):**

```bash
curl -s -H "x-api-key: ai_lure_<yourkey>" https://<repl-domain>/api/v1/ping
# => {"ok":true,...}
```

**AI Mode (return URL):**

```bash
curl -s -X POST "https://<repl-domain>/api/v1/heatmap/ai" \
  -H "content-type: application/json" \
  -H "x-api-key: ai_lure_<yourkey>" \
  -d '{"url":"https://www.acquisition.com/","viewport":{"width":1440,"height":900},"return":"url"}'
# => { "url": "/outputs/ai_xxx.png", "meta": {...} }
```

**AI Mode (return base64):**

```bash
curl -s -X POST "https://<repl-domain>/api/v1/heatmap/ai" \
  -H "content-type: application/json" \
  -H "x-api-key: ai_lure_<yourkey>" \
  -d '{"url":"https://www.acquisition.com/","return":"base64"}'
```

**Data Mode (multipart upload):**

```bash
curl -s -X POST "https://<repl-domain>/api/v1/heatmap/data" \
  -H "x-api-key: ai_lure_<yourkey>" \
  -F "file=@user_data.jsonl" \
  -F 'return=url' \
  -F 'url=https://www.acquisition.com/'
# => { "segments": { "desktop": {"url":"/outputs/data_desktop_x.png"} ... } }
```

**Data Mode (dataUrl):**

```bash
curl -s -X POST "https://<repl-domain>/api/v1/heatmap/data" \
  -H "content-type: application/json" \
  -H "x-api-key: ai_lure_<yourkey>" \
  -d '{"url":"https://www.acquisition.com/","dataUrl":"https://.../user_data.jsonl","return":"url"}'
```

---

## 9) Guardrails & Performance

* **Browser reuse**: Only one Chromium instance; close pages after each job.
* **Timeouts**: 120s nav timeout; 150s request timeout; fail fast on invalid URLs.
* **Memory**: Stream `.jsonl` line-by-line; do not `JSON.parse` the whole file at once.
* **Scroll-aware Y**: `absY = sy * (pageHeight - viewportHeight) + y * viewportHeight`.
* **Segments**: Never mix data between desktop/tablet/mobile.
* **Overlay**: Render on a *copy* of screenshot; keep original buffer intact.
* **Logging**: Use existing `vite.ts` `log()` wrapper or add `pino` for JSON logs. Log request id, timing, counts of points per segment.
* **Limits**: If needed, enforce a max number of points (e.g., 200k per segment) and decimate with stratified sampling.

---

## 10) Code Hooks to Add (exact lines/places)

* **`server/routes.ts`**: after `registerPingRoute(app);`

  ```ts
  import { registerHeatmapRoutes } from "./routes/heatmap";
  // ...
  registerHeatmapRoutes(app);
  ```

* **`server/index.ts`**: ensure static serve (if not already)

  ```ts
  app.use(express.static("public"));
  ```

* **`server/routes/heatmap.ts`** (new):

  ```ts
  import type { Express } from "express";
  import multer from "multer";
  import { apiKeyAuth } from "../middleware/apiKeyAuth";
  import { ensurePremium } from "../middleware/ensurePremium";
  import { z } from "zod";
  import { generateAI, generateFromData } from "../services/heatmap";

  const upload = multer({ dest: "uploads/" });

  export function registerHeatmapRoutes(app: Express) {
    app.post("/api/v1/heatmap/ai", apiKeyAuth, ensurePremium, async (req, res) => {
      // validate, call generateAI, return result
    });

    app.post("/api/v1/heatmap/data", apiKeyAuth, ensurePremium, upload.single("file"), async (req, res) => {
      // resolve file vs dataUrl, call generateFromData, return result
    });
  }
  ```

* **`server/services/heatmap.ts`**: replace the 1×1 PNG stub with real calls to the new `lib/*` modules.

---

## 11) “Done” Criteria

* ✅ `POST /api/v1/heatmap/ai` returns a PNG (URL or base64) that visually highlights above-the-fold elements.
* ✅ `POST /api/v1/heatmap/data` returns up to 3 images (desktop/tablet/mobile) aligned with real coordinates from `.jsonl`, including interactions **below the fold**.
* ✅ Images appear under `public/outputs/` when `return:"url"`, and are accessible via `<repl-domain>/outputs/<file>.png`.
* ✅ No TS path aliases or CJS/ESM mismatch warnings. Build works with `npm run build` and boots with `npm start`.
* ✅ Rate limiting and API key middleware still apply. No change to other routes.

---

## 12) Nice-to-Haves (post-MVP)

* SSE `/api/v1/heatmap/progress/:jobId` to stream progress (% sessions parsed, segments rendered).
* Cache screenshots by URL+viewport hash for 5 minutes.
* Add a React page to list past outputs and open them side-by-side with the source URL.

---

If you follow the steps above *in this repo*, the web app will produce both AI and Data heatmaps reliably on Replit, while keeping your current stack (auth, Vite middleware, DB scaffolding) intact.
