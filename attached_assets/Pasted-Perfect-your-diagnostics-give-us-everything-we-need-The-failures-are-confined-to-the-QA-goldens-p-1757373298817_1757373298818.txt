Perfect—your diagnostics give us everything we need. The failures are confined to the **QA/goldens path**, not the live endpoints. Below is a tight, file-by-file instruction list for your Replit assistant to fix Phase-8 QA without touching the working AI/data routes.

---

# Phase 8 — QA/Goldens Fix Plan (Do this exactly)

## TL;DR of what’s broken

* `/api/v1/qa/generate-goldens` throws:

  > `./services/renderer does not provide an export named 'renderDataHeatmapToCanvas'`
* Diagnostics shows `qa_error` because QA cannot render/compare.
* Screenshot provider is **not configured** (diagnostics shows `providerConfigured:false`), so QA must **not** depend on provider or AI.

We’ll make QA **deterministic**, **provider-free**, and **AI-free**.

---

## 1) Create a dedicated renderer module (and export the expected function)

**File:** `server/services/renderer.ts` (new or replace the stub the assistant tried)

**Exports (must be **named** exports):**

```ts
export function getViewportForDevice(device: "desktop"|"tablet"|"mobile"): { width:number; height:number };
export function makeDeterministicPoints(): Array<{ x:number; y:number; w?:number }>;
export async function renderDataHeatmapToCanvas(
  screenshot: Buffer,                  // exact dimensions = viewport
  viewport: { width:number; height:number },
  points: Array<{ x:number; y:number; w?:number }>,
  opts?: { alpha?: number; radius?: number; ramp?: "classic"|"soft"; blend?: "lighter"|"source-over" }
): Promise<import("@napi-rs/canvas").Canvas>;

export function computePSNR(a: Buffer, b: Buffer, width: number, height: number): { mse:number; psnr:number };

export async function savePng(canvas: import("@napi-rs/canvas").Canvas, outPath: string): Promise<void>;

// QA-only helpers (no provider, no AI)
export async function loadQABaseScreenshot(device: "desktop"|"tablet"|"mobile"): Promise<Buffer>; // see §2
export async function renderDeterministicQA(url: string, device: "desktop"|"tablet"|"mobile"): Promise<{ png: Buffer; width:number; height:number }>;
```

**Implementation notes (no full code, but enforce these constraints):**

* Use `@napi-rs/canvas` only (`createCanvas`, `loadImage` if you use base fixtures).
* `getViewportForDevice` returns **exact** sizes:

  * desktop: `1920×1080`, tablet: `1024×768`, mobile: `414×896`.
* `makeDeterministicPoints()` returns a **fixed** array (no randomness), e.g.:

  ```
  [{x:0.50,y:0.20},{x:0.60,y:0.25},{x:0.55,y:0.22},{x:0.33,y:0.45},{x:0.72,y:0.62}]
  ```
* `renderDataHeatmapToCanvas` composes:

  1. Draw the screenshot buffer (must match viewport).
  2. Draw heat layer from points (Gaussian/kde) with fixed knobs (alpha=0.6, radius=32, ramp="classic", blend="lighter").
  3. Return a Canvas (not a PNG buffer).
* `loadQABaseScreenshot(device)` MUST **not** call provider nor AI. It loads a **base image** from disk (see §2).
* `renderDeterministicQA(url, device)`:

  * Derive viewport via `getViewportForDevice`.
  * `const screenshot = await loadQABaseScreenshot(device)` (this guarantees dimensions).
  * `const points = makeDeterministicPoints()`.
  * `const canvas = await renderDataHeatmapToCanvas(screenshot, viewport, points, {alpha:0.6,...})`.
  * Return `{ png: canvas.toBuffer("image/png"), width, height }`.
* `computePSNR()` compares **same-size** RGBA buffers; if `MSE==0`, set `PSNR=100`.

> ✅ This satisfies the missing export and removes any dependency on screenshots/AI for QA.

---

## 2) Add predictable base images for QA (no network)

**Directory:** `public/qa/` (ensure it exists on startup)

**Place three base files** (commit them to the repo):

* `public/qa/base-desktop.png`   → **1920×1080**
* `public/qa/base-tablet.png`    → **1024×768**
* `public/qa/base-mobile.png`    → **414×896**

These can be **blank canvases** or a simple static fixture. What matters is that their dimensions match the viewport exactly and they’re stable.

**Rationale:** We avoid external screenshot providers entirely for QA. Goldens will be an overlay of our deterministic points over these base images.

---

## 3) Fix the goldens generator route to use the renderer

**File:** `server/routes.ts` **or** wherever `/api/v1/qa/generate-goldens` lives

**What to change:**

* Import the **named** exports from the renderer:

  ```ts
  import {
    getViewportForDevice,
    renderDeterministicQA,
    savePng
  } from "./services/renderer";
  ```
* For each requested device:

  1. Call `renderDeterministicQA(body.url, device)` (URL is ignored by QA render; it’s part of the key only).
  2. Save to `public/qa/golden-${device}.png` using `savePng` (or `fs.writeFile` if you already have the buffer).
* Respond with JSON listing which goldens were written and their sizes.

**Acceptance:** calling `POST /api/v1/qa/generate-goldens` returns 200 and writes all `golden-*.png`.

---

## 4) Make the diagnostics QA block robust (no “qa\_error”)

**File:** `server/diagnostics.ts` (or wherever `/api/v1/heatmap/diagnostics` is implemented)

When `?qa=1`:

1. For each device:

   * Load `public/qa/golden-${device}.png`.
   * Generate **current** deterministic QA render via `renderDeterministicQA(...)` (same device).
   * If golden missing → report `{ pass:false, reason:"missing_golden" }` (no 500).
   * If dimensions differ → `{ pass:false, reason:"dimension_mismatch", goldenSize:{w,h}, renderSize:{w,h} }`.
   * Else compute PSNR (see exported `computePSNR`) and set:

     * `pass = (psnr >= 35)`
     * include `mse`, `psnr` for visibility.
2. Return under `qa`:

```json
"qa": [
  { "device":"desktop","goldenFound":true,"goldenSize":{"width":1920,"height":1080},"renderSize":{"width":1920,"height":1080},"mse":123,"psnr":38.7,"pass":true },
  ...
]
```

> **Important:** QA must *not* look at provider health. Keep it independent.

---

## 5) Provider flags must not block QA

**File:** `server/diagnostics.ts`
Keep `providers.screenshot.active=false` if there’s no key—that’s fine. QA should still run and pass because it uses local base images, not providers.

---

## 6) Re-run your two commands (expected results)

### 6.1 Generate goldens

```powershell
$BASE = "https://60018a49-32e3-45ec-92e9-e671294eff18-00-2ctgykht9dlk2.spock.replit.dev"
$body = @{ url = "https://www.example.com"; devices = @("desktop","tablet","mobile") }
Invoke-WebRequest -Uri "$BASE/api/v1/qa/generate-goldens" `
  -Method POST -ContentType "application/json" `
  -Body ($body | ConvertTo-Json -Depth 10) | Select -Expand Content
```

**Expect:** 200 JSON listing `golden-desktop.png`, `golden-tablet.png`, `golden-mobile.png` written with correct sizes.

### 6.2 Diagnostics with QA

```powershell
Invoke-WebRequest -Uri "$BASE/api/v1/heatmap/diagnostics?qa=1&verbose=1" -Method GET |
  Select -Expand Content
```

**Expect (per device):**

* `goldenFound: true`
* `goldenSize == renderSize`
* `psnr >= 35`
* `pass: true`

Then run your **Phase-8 smoke** again (no edits needed). Test 7 should flip to **PASS**.

---

## 7) Safety rails

* If `public/qa/base-*.png` are missing, the goldens route should return 400 with a clear message: `missing_base_fixture`.
* If any canvas op fails, never crash diagnostics—return `{ pass:false, reason:"render_failed" }` per device.
* Redact everything; no massive buffers in logs.

---

## 8) Quick checklist for your assistant

* [ ] Create/repair `server/services/renderer.ts` with **named** exports listed in §1.
* [ ] Ensure `@napi-rs/canvas` is used (no `canvas` mix).
* [ ] Add `public/qa/base-desktop.png` (1920×1080), `base-tablet.png` (1024×768), `base-mobile.png` (414×896).
* [ ] Update `/api/v1/qa/generate-goldens` to call `renderDeterministicQA()` and write `golden-*.png`.
* [ ] Update diagnostics `?qa=1` path to load goldens, render deterministic, compare via PSNR; no provider/AI.
* [ ] Add verbose diagnostics fields: `goldenFound`, `goldenSize`, `renderSize`, `mse`, `psnr`, `reason` (when failing).
* [ ] Do **not** change `/api/v1/heatmap` or `/api/v1/heatmap/data` contracts (they are passing).

If you hit anything odd after this pass, paste the JSON from `diagnostics?qa=1&verbose=1` and I’ll pinpoint quickly (dimension mismatch vs missing goldens vs PSNR math).
