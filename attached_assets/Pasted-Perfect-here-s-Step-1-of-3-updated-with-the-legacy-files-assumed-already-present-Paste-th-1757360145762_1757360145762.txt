Perfect—here’s **Step 1 of 3 (updated)** with the legacy files assumed **already present**. Paste this to the Replit assistant.

---

# Step 1 — Hotspots JSON API (parity-safe, legacy-aware, no rendering)

**Goal:** Add a debug endpoint that returns hotspots as JSON with a strict schema, supports both **phase7 AI** and **legacy engine**, enforces **parity rules**, and does **not** render images yet.

## A) Files to add / modify (legacy files are already done — do not touch them)

1. `server/services/validation.ts`
   Implement:

   * `ALLOWED_DEVICES = ["desktop","tablet","mobile"] as const`
   * `DEVICE_MAP = { desktop:{width:1920,height:1080}, tablet:{width:1024,height:768}, mobile:{width:414,height:896} }`
   * Zod (or equivalent) validators:

     * device ∈ ALLOWED\_DEVICES
     * Hotspot schema:

       ```
       { x:number; y:number; width:number; height:number; confidence:number; element_type:"headline"|"cta"|"logo"|"hero"|"product"|"price"|"other"; reason:string }
       ```

       All numbers must be clamped to \[0,1]; width/height > 0.
   * Helpers:

     * `clampAndValidateHotspots(list): { kept: Hotspot[]; dropped: number }`
     * `greedyDeoverlap(list, { max: 8, iouThreshold: 0.4 }): Hotspot[]` (confidence-desc, keep if IoU < 0.4)

2. `server/services/aiHotspots.ts`  *(phase7 engine)*
   Export:

   * `getAiHotspotsPhase7({ url, device, parity }: { url:string; device:"desktop"|"tablet"|"mobile"; parity:boolean }): Promise<{ hotspots: Hotspot[]; meta: { engine:"phase7"; model:"gpt-4o-mini"; fallback:boolean; requested:number; accepted:number; pruned:number; promptHash:string } }>`
     Behavior:
   * If `OPENAI_API_KEY` missing → set `fallback:true` and return **fallback hotspots** (see C).
   * Else call **Chat Completions** (`model:"gpt-4o-mini"`, `temperature:0.3`, `max_tokens:1000`, `response_format:{type:"json_object"}`) with a concise prompt requiring **exact JSON**:

     ```json
     { "hotspots":[ { "x":0.42,"y":0.18,"width":0.32,"height":0.10,"confidence":0.78,"element_type":"cta","reason":"..." } ] }
     ```
   * Parse JSON → `clampAndValidateHotspots` → `greedyDeoverlap`.
   * If `parity===true`: enforce **≤8** hotspots, IoU<0.4, drop confidence<0.25.
   * If list empty after sanitization → fallback.

3. `server/services/aiHotspots.legacy.ts`  *(legacy adapter)*
   Export:

   * `getAiHotspotsLegacy({ url, device, parity }): Promise<{ hotspots: Hotspot[]; meta: { engine:"legacy"; checksumOk:boolean } }>`
     Behavior:
   * **Verify checksum** of `attached_assets/ai-engines/legacy/heatmap_v1.js` against `attached_assets/ai-engines/legacy/heatmap_v1.sha256`.

     * On mismatch → **500** with message: `"Legacy engine checksum mismatch (refuse to run)"`
   * **Spawn** the legacy script as a child process (pass `--url`, `--device`, `--json` if supported) and capture **stdout JSON** hotspots.
   * Sanitize via `clampAndValidateHotspots` → `greedyDeoverlap`.
   * Apply parity rules if `parity===true`.

4. `server/app-routes.ts` (or your main router)
   Add **a new route only**:

   * `POST /api/v1/heatmap/hotspots`

     * Input JSON:
       `{ "url": string, "device"?: "desktop"|"tablet"|"mobile", "engine"?: "legacy"|"phase7", "parity"?: boolean }`

       * Defaults: `device="desktop"`, `engine` from env `AI_ENGINE` (default `"phase7"`), `parity=true`.
     * Flow:

       1. Validate `url` and `device`.
       2. If `engine==="legacy"` → `getAiHotspotsLegacy`; else → `getAiHotspotsPhase7`.
       3. Re-run sanitize + de-overlap (belt & suspenders).
       4. Respond **200** with:

          ```
          {
            "hotspots": [...],
            "meta": {
              "phase": "phase7",
              "engine": "ai",
              "device": "...",
              "viewport": { "width": ..., "height": ... },
              "ai": {
                "engine": "legacy" | "phase7",
                "model": "legacy" | "gpt-4o-mini",
                "fallback": boolean,
                "promptHash": "<if phase7>",
                "checksumOk": <if legacy>,
                "requested": N,
                "accepted": K,
                "pruned": P,
                "parity": true|false
              },
              "timestamp": "ISO-8601",
              "durationMs": number
            }
          }
          ```
     * Logging (one line, structured): `{ route:"/api/v1/heatmap/hotspots", url, device, engine, parity, durationMs, accepted, pruned, fallback }`
   * **Do not** change `/api/v1/heatmap` or `/api/v1/heatmap/data` in this step.

## B) Parity rules enforced in this step

* Bounds: all x,y,width,height,confidence ∈ \[0,1].
* Counts: after pruning, **1..8** hotspots.
* IoU: greedy de-overlap with threshold **0.4**.
* Confidence floor: drop `< 0.25`.
* Deterministic fallback if empty/invalid.

## C) Fallback hotspot spec (used by both engines when needed)

* Return 3–5 normalized boxes:

  * \~top-center hero, \~top-right CTA, \~fold (y≈0.75–0.85).
  * width/height ≈ 0.15–0.35; confidence 0.55–0.70.
* Apply same parity rules (bounds, IoU, ≤8).

## D) Acceptance checks (must pass)

1. **Happy (phase7)**
   POST `/api/v1/heatmap/hotspots` with `{ "url":"https://www.acquisition.com","device":"desktop" }`
   → **200**, `1..8` hotspots, all numbers in \[0,1], `meta.phase==="phase7"`, `meta.ai.engine==="phase7"`, `meta.ai.parity===true`.

2. **Fallback (no key)**
   Remove/blank `OPENAI_API_KEY`, same request
   → **200**, `meta.ai.fallback===true`, still `1..8` hotspots.

3. **Legacy path**
   POST with `{ "url":"...","engine":"legacy" }`
   → **200**, `meta.ai.engine==="legacy"`, `meta.ai.checksumOk===true`.
   If you temporarily corrupt `heatmap_v1.js` (do not commit), it should 500 with `"Legacy engine checksum mismatch"`.

4. **Invalid inputs**
   Missing `url` → **400** `{ error: "URL is required" }`
   `device:"watch"` → **400** with allowed list.

5. **De-overlap**
   Confirm IoU < 0.4 and ≤8 after pruning (spot-check).

## E) Non-goals for this step

* No image rendering, no screenshot calls, no UI changes.

---

This keeps your legacy engine intact (checksum-verified), gives us a strict, parity-safe JSON contract, and sets up Step 2 to plug these hotspots into the renderer.
