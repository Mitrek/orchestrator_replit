Awesomeâ€”on to **Step 3 of 3** ðŸŽ¯
Below are **precise, copy-pastable instructions** for your Replit AI assistant. (No codeâ€”just what to change/add.)

---

# Phase 5 â€” Step 3: Color ramp + alpha + composite over screenshot â†’ final PNG

**Goal:** Turn the accumulated heat buffer into a colored heat layer, blend it over the screenshot, and return a single PNG (base64 or URL). Keep the greyscale debug from Step 2 as an optional field.

## Instructions for Replit AI assistant

1. **Controller: upgrade `postHeatmapData` (no new routes)**

   * File: `server/controllers/heatmap.data.ts`
   * After Step-2â€™s accumulation/blur, add **colorization + compositing** stage.
   * Accept these additional optional knobs in request body (with defaults):

     * `alpha?: number` (default **0.60**, clamp to 0..1)
     * `blendMode?: "lighter" | "source-over"` (default **"lighter"**)
     * `ramp?: "classic" | "soft"` (default **"classic"**)
     * `clipLowPercent?: number` (default **0**)
     * `clipHighPercent?: number` (default **100**)
     * `returnMode?: "base64" | "url"` (default **"base64"**)
   * Preserve `debugHeat` behavior from Step 2 (greyscale heat layer is optional, downscaled).
   * Response (success) must return:

     ```json
     {
       "image": "data:image/png;base64,...",  // or { "url": "/heatmaps/..." } when returnMode==="url"
       "meta": {
         "sourceUrl": "<url>",
         "device": "<desktop|tablet|mobile>",
         "countPoints": <int>,
         "radiusPx": <int>,
         "blurPx": <int>,
         "alpha": <number>,
         "blendMode": "<lighter|source-over>",
         "ramp": "<classic|soft>",
         "clipLowPercent": <number>,
         "clipHighPercent": <number>,
         "phase": "phase5.step3"
       },
       "debug": {
         "heatLayerGray": "data:image/png;base64,..."   // only when debugHeat=true and not oversized
       }
     }
     ```
   * Error cases to keep:

     * If compositing fails â†’ **500** `{ "error":"composite_failed", "phase":"composite" }`.
     * If colorization fails â†’ **500** `{ "error":"colorize_failed", "phase":"colorize" }`.

2. **Service: colorize + composite**

   * File: `server/services/imaging.ts` (extend this file rather than making a new one).

   * Add functions:

     * `heatBufferToColorRgba(buffer, width, height, { ramp, clipLowPercent, clipHighPercent }): Uint8ClampedArray`

       * Compute min/max from buffer, then percentile-clip using `clipLowPercent`/`clipHighPercent`.
       * Normalize to 0..1 and map using a **ramp**:

         * `"classic"`: blue â†’ cyan â†’ green â†’ yellow â†’ red (as in your north-star `heatmap.js`).
         * `"soft"`: deep blue â†’ teal â†’ lime â†’ amber â†’ orange (lower saturation mid-tones).
       * Return RGBA data with **A = 255 where value > 0**, else A = 0.
     * `compositeHeatOverScreenshot({ screenshotPngBase64, heatRgba, width, height, alpha, blendMode }): dataUrlBase64`

       * Create a canvas with `width/height`. Draw screenshot, then the heat layer.
       * Apply global alpha = `alpha` (clamped), set `globalCompositeOperation = blendMode`.
       * Export **PNG data URL** (`data:image/png;base64,...`).
     * Keep existing: `heatBufferToGreyscalePngBase64` for debug.

   * **Memory guardrails** (important):

     * If `width*height > 8e6` (â‰ˆ8MP), **downscale the heat layer to a working resolution**, composite there, and (only when `returnMode==="url"`) optionally upscale when saving. For `base64` return, just return the composited downscaled image to avoid OOM on Replit.
     * Preserve Step-2 downscaling for the debug greyscale.

3. **Filesystem path (URL mode)**

   * Ensure the static dir exists: `public/heatmaps`.
   * When `returnMode === "url"`, write the composited PNG as `heatmap-<timestamp>-<shortid>.png` and return `{ "url": "/heatmaps/<filename>", ... }`.
   * Keep the same static mount already configured in the server.

4. **Logging**

   * Add structured logs around the new phases: `{ phase:"colorize", ramp, clipLowPercent, clipHighPercent }` and `{ phase:"composite", alpha, blendMode }`.
   * Log durations for colorize/composite just like you did for map/accumulate/blur.

5. **Definition of Done (Step 3)**

   * POST `/api/v1/heatmap/data` returns a **final heatmap image** (colored & composited) as base64 or URL.
   * Greyscale debug still works when `debugHeat=true`, but may be downscaled for large pages.
   * Knobs (`alpha`, `blendMode`, `ramp`, `clipLowPercent`, `clipHighPercent`) affect output deterministically.
   * Clear 5xx error messages when colorize/composite fail, with `phase` included.

6. **Acceptance tests to run (after implementation)**

   * **Happy path** (desktop, base64):

     * `url: "https://example.com"`, points clustered at center; expect a visible hot region over the hero, `meta.phase === "phase5.step3"`.
   * **Ramp & alpha:**

     * Compare `ramp="classic"` vs `"soft"`; colors change but hotspot position identical.
     * Set `alpha=0.2` vs `alpha=0.8`; visibly lighter/darker overlay.
   * **Clipping:**

     * With many points, set `clipHighPercent=95`; expect fewer saturated reds.
     * With sparse points, set `clipLowPercent=10`; background noise suppressed.
   * **URL mode:**

     * `returnMode="url"` returns `url` and file exists under `/heatmaps/â€¦`.
   * **Debug image:**

     * `debugHeat=true` returns `debug.heatLayerGray` for normal-sized pages; if page is huge, debug may be downscaled (still a PNG data URL).

---

When you get a green light on these, youâ€™ve completed Phase 5. If you want, I can hand you a compact smoketest for Step-3 (one page, three requests toggling ramp/alpha/clip) to quickly validate visuals and metadata.
